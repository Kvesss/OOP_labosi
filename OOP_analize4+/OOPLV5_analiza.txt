//1. zad

#include<iostream>
#include<ctime>
#include<cstdlib>
#include<stdexcept>
using namespace std;



class StogExc : public runtime_error {
	int size;

	int pos;
public:
	StogExc() :size(0), pos(-1),runtime_error("Problem neki") {}
	StogExc(int a, string msg) :runtime_error(msg), size(a) {
	}
	};

	template<typename T>
	class Stack {
	private:
		int size;
		T* data;
		int pos;
	public:
		Stack(int n) :size(n), pos(-1) {
			if (n<0) {
				throw StogExc(n, "Nemoguce kreirati stog! ");
			}
			data = new T[size];
		}
		~Stack() { delete[] data; }
		Stack(const Stack& Ref) :size(Ref.size), pos(Ref.pos) {
			this->data = new T[size];
			for (int i = 0; i < size; i++) {
				data[i] = Ref.data[i];
			}
		}
		Stack& operator=(const Stack& Ref)
		{
			if (&Ref == this) return *this;
			delete[] data;
			this->size = Ref.size;
			this->pos = Ref.pos;
			this->data = new T[size];
			for (int i = 0; i < size; i++) {
				data[i] = Ref.data[i];
			}
			return *this;
		}
		void push(T el) {
			if (size > pos + 1) {
				pos++;
				data[pos] = el;
			}
			else
				//cout << "Stack popunjen" << endl;
				throw StogExc(size, "Stog je popunjen! ");
		}
		void pop() {
			if (pos > -1) {
				pos--;
			}
			else
				//cout << "Prazan stack" << endl;
				throw StogExc(size, "Stog je prazan! ");
		}
		T peek() {
			if (data[pos] == NULL) {
				throw StogExc(size, "Stog je prazan! ");
	
			}
			return data[pos];
		}
	};
	int main() {
		srand(time(NULL));


		try {
			Stack <double> s1(10);
			Stack <int> s2(-1);
			for (int i = 0; i < 10; i++) {
				s1.push((double)rand() / RAND_MAX * (10));
			}
		}
		catch (const StogExc& exc) {
			cout << exc.what() << endl;
		}
		
		try{
		    Stack <double> s1(10);
			Stack <int> s2(5);
			for (int i = 0; i < 7; i++) {
				s2.push(5 + rand() % (11));
			}
		}
		catch (const StogExc& exc) {
			cout << exc.what() << endl;
		}
			
		try{
		    Stack <double> s1(10);
			Stack <int> s2(5);
			double peek=s1.peek();
			s1.pop();
		}
		catch (const StogExc& exc) {
			cout << exc.what() << endl;
		}

		return 0;
	}


//2. zad


#include<iostream>
#include<ctime>
#include<cstdlib>
#include<stdexcept>
using namespace std;

class ExcRazlomak: public runtime_error{
    int b,n;
public:
    ExcRazlomak(int bb,int nn, string msg):runtime_error(msg),b(bb),n(nn){}    
};


class Razlomak{
private:
    int b;
    int n;
public:
    Razlomak (int x=0, int y=1):b(x),n(y) {
        if (y==0)
            throw ExcRazlomak(x,y,"Nemoguce stvaranje razlomka s nazivnikom 0 !");
    }
    friend Razlomak operator== (const Razlomak& ,const Razlomak& );
    friend Razlomak operator/ (const Razlomak& , const Razlomak& );
};
Razlomak operator== (const Razlomak& r1,const Razlomak& r2)
{
return r1.b*r2.n == r1.n*r2.b;
}

Razlomak operator/ (const Razlomak& r1, const Razlomak& r2){
    if(r2.b==0)
        throw ExcRazlomak(r2.b,r2.n,"Rezultat je nazivnik s nulom!");
    return Razlomak(r1.b*r2.n,r1.n*r2.b);
}


int main(){
    try{
        Razlomak prvi(2,4);
        Razlomak drugi(2,0);
    }
    catch(const ExcRazlomak& exc){
        cout<<exc.what()<<endl;
    }
    try{
        Razlomak prvi(2,4);
        Razlomak drugi(0,2);
        Razlomak treci= prvi/drugi;
    }
    catch(const ExcRazlomak& exc2){
        cout<<exc2.what()<<endl;
    }
    
    return 0;
}